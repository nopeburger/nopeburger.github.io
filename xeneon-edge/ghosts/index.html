
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Ghosts by Nopeburger</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.4/p5.min.js"></script>
    <style>
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background-color: #000; touch-action: none; }
        canvas { display: block; outline: none; }
    </style>
</head>
<body>

    <!-- Shader & Logic -->
    <script>
        const vertShader = `
            attribute vec3 aPosition;
            attribute vec2 aTexCoord;
            uniform mat4 uModelViewProjectionMatrix;
            varying vec2 vTexCoord;
            void main() {
                vTexCoord = aTexCoord;
                gl_Position = uModelViewProjectionMatrix * vec4(aPosition, 1.0);
            }
        `;

        const fragShader = `
            precision highp float;
            varying vec2 vTexCoord;
            uniform vec2 u_resolution;
            uniform float u_time;
            uniform float u_seed; // Seed for randomizing palette
            uniform vec3 u_blobs[100]; 
            uniform int u_blob_count;

            // --- Noise Functions ---
            vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
            vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }

            float snoise(vec3 v) { 
                const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;
                const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);
                vec3 i  = floor(v + dot(v, C.yyy) );
                vec3 x0 = v - i + dot(i, C.xxx) ;
                vec3 g = step(x0.yzx, x0.xyz);
                vec3 l = 1.0 - g;
                vec3 i1 = min( g.xyz, l.zxy );
                vec3 i2 = max( g.xyz, l.zxy );
                vec3 x1 = x0 - i1 + C.xxx;
                vec3 x2 = x0 - i2 + C.yyy; 
                vec3 x3 = x0 - D.yyy;      
                i = mod289(i); 
                vec4 p = permute( permute( permute( 
                        i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
                        + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) 
                        + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));
                float n_ = 0.142857142857; 
                vec3  ns = n_ * D.wyz - D.xzx;
                vec4 j = p - 49.0 * floor(p * ns.z * ns.z); 
                vec4 x_ = floor(j * ns.z);
                vec4 y_ = floor(j - 7.0 * x_ );    
                vec4 x = x_ *ns.x + ns.yyyy;
                vec4 y = y_ *ns.x + ns.yyyy;
                vec4 h = 1.0 - abs(x) - abs(y);
                vec4 b0 = vec4( x.xy, y.xy );
                vec4 b1 = vec4( x.zw, y.zw );
                vec4 s0 = floor(b0)*2.0 + 1.0;
                vec4 s1 = floor(b1)*2.0 + 1.0;
                vec4 sh = -step(h, vec4(0.0));
                vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
                vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;
                vec3 p0 = vec3(a0.xy,h.x);
                vec3 p1 = vec3(a0.zw,h.y);
                vec3 p2 = vec3(a1.xy,h.z);
                vec3 p3 = vec3(a1.zw,h.w);
                vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
                p0 *= norm.x;
                p1 *= norm.y;
                p2 *= norm.z;
                p3 *= norm.w;
                vec4 m = max(0.5 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
                m = m * m;
                return 105.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), 
                                            dot(p2,x2), dot(p3,x3) ) );
            }

            // HSB to RGB conversion for clean complementary colors
            vec3 hsb2rgb( vec3 c ){
                vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),
                                        6.0)-3.0)-1.0,
                                0.0,
                                1.0 );
                rgb = rgb*rgb*(3.0-2.0*rgb);
                return c.z * mix( vec3(1.0), rgb, c.y);
            }

            void main() {
                vec2 uv = vTexCoord;
                uv.y = 1.0 - uv.y; 
                
                float aspect = u_resolution.x / u_resolution.y;
                vec2 st = uv;
                st.x *= aspect;

                // Slowed down time for very fluid, smooth movement (noise evolution)
                float t = u_time * 0.05;

                // --- Dynamic Complementary Color Generation ---
                // Moved to top so background can use it
                float hueSpeed = 0.02; // Slow evolution
                float primaryHue = mod(u_seed * 0.05 + t * hueSpeed, 1.0);
                
                // Create two complementary colors (180 degrees apart in HSB)
                vec3 colA = hsb2rgb(vec3(primaryHue, 0.9, 0.95));       // Color A
                vec3 colB = hsb2rgb(vec3(mod(primaryHue + 0.5, 1.0), 0.9, 0.95)); // Color B (Complement)

                // --- Background Noise (RGB Ripples) ---
                float bgNoise = snoise(vec3(st * 2.5, t * 0.5));
                float ripple = sin(length(st - vec2(aspect*0.5, 0.5)) * 12.0 - u_time * 1.0 + bgNoise * 3.0);
                
                // --- Background Color ---
                // Synchronized with main colors (Desaturated and Darker)
                vec3 bgColA = hsb2rgb(vec3(primaryHue, 0.5, 0.12)); 
                vec3 bgColB = hsb2rgb(vec3(mod(primaryHue + 0.5, 1.0), 0.5, 0.12));
                
                // Mix background based on noise
                float bgMix = smoothstep(-0.5, 0.5, bgNoise);
                vec3 bgCol = mix(bgColA, bgColB, bgMix);
                
                // Add subtle ripple highlights (tinted with the complementary color)
                bgCol += ripple * 0.03 * mix(colA, colB, 1.0 - bgMix);

                // --- Liquid Domain Warping ---
                float noiseScale = 1.2;
                float warpStrength = 0.12; 
                float n1 = snoise(vec3(st.x * noiseScale, st.y * noiseScale, t));
                vec2 warpedSt = st + vec2(n1) * warpStrength;

                // --- Metaball Field ---
                float potential = 0.0;
                potential += smoothstep(-0.5, 0.8, n1) * 0.15; 

                for (int i = 0; i < 100; i++) {
                    if (i >= u_blob_count) break;
                    vec3 bPos = u_blobs[i];
                    vec2 pos = bPos.xy;
                    pos.x *= aspect;
                    float distSq = dot(warpedSt - pos, warpedSt - pos);
                    potential += (bPos.z * bPos.z) / (distSq + 0.002);
                }
                
                // --- "Liquid Glass" Rendering ---
                
                // Gooey Distortion (Low frequency noise to deform rings into blobs)
                // Replaces high-freq jitter to create organic "lava lamp" shapes
                float gooNoise = snoise(vec3(warpedSt * 2.0, t * 0.5));
                float distortion = gooNoise * 0.25; 

                // Base T for banding with distortion
                float baseT = potential * 0.1 + distortion;
                
                float dispersion = 0.05; 
                float ringFreq = 1.0;   
                
                // Blur the inner rings based on potential
                float blurFactor = smoothstep(0.35, 0.9, potential);
                float waveAmp = mix(1.0, 0.15, blurFactor); // 1.0 = sharp rings, 0.15 = very blurred/blended
                
                vec3 glassColor;
                
                // Mix complementary colors using the ring pattern for each channel
                // We multiply the cosine part by waveAmp to dampen the oscillation in the center
                // Increased speed of growth effect (u_time * 1.5) which is 200% faster than 0.5
                
                // R
                float tR = baseT - dispersion;
                float mixR = 0.5 + 0.5 * waveAmp * cos(tR * ringFreq + u_time * 1.5);
                glassColor.r = mix(colA.r, colB.r, mixR);
                
                // G
                float tG = baseT;
                float mixG = 0.5 + 0.5 * waveAmp * cos(tG * ringFreq + u_time * 1.5);
                glassColor.g = mix(colA.g, colB.g, mixG);
                
                // B
                float tB = baseT + dispersion;
                float mixB = 0.5 + 0.5 * waveAmp * cos(tB * ringFreq + u_time * 1.5);
                glassColor.b = mix(colA.b, colB.b, mixB);
                
                // Alpha/Surface definition
                // Use distortion here too so the shape matches the bands
                float surface = smoothstep(0.3, 0.7, potential + distortion);
                
                // --- Inner Glow (Additive Blending) ---
                // Detect inner area based on potential magnitude
                float innerGlow = smoothstep(0.5, 1.2, potential); // Tuning for inner core
                
                // Composite
                // Glass color + additive glow
                // We boost the glassColor where potential is high to make rings glow
                vec3 fluidComp = glassColor + (glassColor * innerGlow * 2.5); 
                
                // Mix with background
                // Decreased opacity to 50% (0.5)
                vec3 color = mix(bgCol, fluidComp, surface * 0.5);

                gl_FragColor = vec4(color, 1.0);
            }
        `;

        const sketch = (p) => {
            let shaderProgram;
            let blobs = [];
            
            // Seeds for color randomization
            let currentSeed = 0;
            let targetSeed = 0;
            
            // Color Change Throttling
            let lastColorChangeTime = 0;
            const COLOR_COOLDOWN = 3000; // 3000ms = 3 seconds
            
            // Idle Auto-Cycle
            let nextAutoCycleTime = 0;
            
            class BlobEntity {
                constructor(x, y) {
                    this.pos = p.createVector(x, y);
                    this.vel = p5.Vector.random2D().mult(3);
                    this.history = [];
                    this.maxHistory = 40; 
                }

                // Continuous Repulsion Force (Dragging physics)
                repel(inputX, inputY, width, height) {
                    let d = p.dist(inputX, inputY, this.pos.x, this.pos.y);
                    let interactRadius = Math.max(width, height) * 0.45;
                    
                    if (d < interactRadius) {
                        let forceDir = p.createVector(this.pos.x - inputX, this.pos.y - inputY).normalize();
                        // Map distance to force strength
                        // Closer = stronger push
                        let strength = p.map(d, 0, interactRadius, 2.5, 0.0);
                        if (strength < 0) strength = 0;
                        
                        forceDir.mult(strength);
                        this.vel.add(forceDir);
                    }
                }

                update(width, height) {
                    this.history.unshift({x: this.pos.x, y: this.pos.y});
                    if (this.history.length > this.maxHistory) this.history.pop();

                    this.pos.add(this.vel);
                    
                    // Soft Wall Repulsion 
                    let margin = 100;
                    let repulsion = 1.2; 
                    
                    if (this.pos.x < margin) this.vel.x += repulsion;
                    if (this.pos.x > width - margin) this.vel.x -= repulsion;
                    if (this.pos.y < margin) this.vel.y += repulsion;
                    if (this.pos.y > height - margin) this.vel.y -= repulsion;

                    // Center Bias 
                    let center = p.createVector(width/2, height/2);
                    let dirToCenter = p5.Vector.sub(center, this.pos);
                    this.vel.add(dirToCenter.mult(0.00005));

                    // Hard Boundaries
                    if (this.pos.x < 0) { this.pos.x = 0; this.vel.x *= -0.8; }
                    if (this.pos.x > width) { this.pos.x = width; this.vel.x *= -0.8; }
                    if (this.pos.y < 0) { this.pos.y = 0; this.vel.y *= -0.8; }
                    if (this.pos.y > height) { this.pos.y = height; this.vel.y *= -0.8; }

                    this.vel.mult(0.98); // Friction
                    
                    // Idle wandering
                    let n = p.noise(this.pos.x * 0.003, this.pos.y * 0.003, p.millis() * 0.0002);
                    let angle = n * p.TWO_PI * 4;
                    this.vel.add(p5.Vector.fromAngle(angle).mult(0.1));

                    if (this.vel.mag() < 0.5) {
                         this.vel.add(p5.Vector.random2D());
                    }
                }
            }

            p.setup = () => {
                p.createCanvas(p.windowWidth, p.windowHeight, p.WEBGL);
                p.pixelDensity(1); 
                shaderProgram = p.createShader(vertShader, fragShader);
                p.noStroke();
                
                currentSeed = p.random(100);
                targetSeed = currentSeed;
                
                // Initialize auto-cycle timer
                nextAutoCycleTime = p.millis() + p.random(5000, 9000);

                blobs.push(new BlobEntity(p.width * 0.3, p.height * 0.5));
                blobs.push(new BlobEntity(p.width * 0.5, p.height * 0.6));
                blobs.push(new BlobEntity(p.width * 0.7, p.height * 0.5));
            };
            
            const triggerColorChange = () => {
                let now = p.millis();
                if (now - lastColorChangeTime < COLOR_COOLDOWN) return;
                lastColorChangeTime = now;
                nextAutoCycleTime = now + p.random(6000, 10000);
                targetSeed = currentSeed + p.random(5.0, 10.0);
            };
            
            p.touchStarted = () => { 
                triggerColorChange();
                return false; 
            };
            
            p.mouseClicked = () => { 
                triggerColorChange();
                return false; 
            };
            
            p.touchMoved = () => {
                return false; // Prevent scroll
            };

            p.draw = () => {
                let now = p.millis();
                
                // Auto-cycle Logic (Idle Behavior - Color Only)
                if (now > nextAutoCycleTime) {
                    targetSeed = currentSeed + p.random(5.0, 10.0);
                    nextAutoCycleTime = now + p.random(5000, 9000);
                }

                // Smoothly interpolate seed for fluid color transitions.
                currentSeed = p.lerp(currentSeed, targetSeed, 0.01);
                
                // Continuous Physics Interaction (Draggable)
                if (p.mouseIsPressed || p.touches.length > 0) {
                    let mx = p.touches.length > 0 ? p.touches[0].x : p.mouseX;
                    let my = p.touches.length > 0 ? p.touches[0].y : p.mouseY;
                    blobs.forEach(b => b.repel(mx, my, p.width, p.height));
                }

                blobs.forEach(b => b.update(p.width, p.height));
                
                let separationPhase = p.noise(p.millis() * 0.0002);
                let sepRadius = Math.min(p.width, p.height) * 0.8;
                let minDist = Math.min(p.width, p.height) * 0.22;

                // Process interactions between all pairs of blobs
                for (let i = 0; i < blobs.length; i++) {
                    for (let j = i + 1; j < blobs.length; j++) {
                        let b1 = blobs[i];
                        let b2 = blobs[j];
                        let d = p5.Vector.dist(b1.pos, b2.pos);

                        if (separationPhase > 0.3) {
                            if (d < sepRadius) {
                                let drift = p5.Vector.sub(b1.pos, b2.pos).normalize();
                                drift.rotate(p.sin(p.millis() * 0.001));
                                drift.mult(0.25);
                                b1.vel.add(drift);
                                b2.vel.sub(drift);
                            }
                        }

                        if (d < minDist) {
                            let normal = p5.Vector.sub(b1.pos, b2.pos).normalize();
                            let force = normal.mult(1.5);
                            b1.vel.add(force);
                            b2.vel.sub(force);
                        }
                    }
                }

                let blobData = [];
                let baseRadius = 0.12;

                blobs.forEach((b, index) => {
                    blobData.push(b.pos.x / p.width, b.pos.y / p.height, baseRadius);

                    for (let i = 0; i < b.history.length; i += 2) { 
                        let h = b.history[i];
                        let trailScale = 1.0 - (i / b.history.length);
                        blobData.push(h.x / p.width, h.y / p.height, baseRadius * 0.5 * trailScale);
                    }
                });

                if (blobData.length > 100 * 3) blobData.length = 100 * 3;

                p.shader(shaderProgram);
                shaderProgram.setUniform('u_resolution', [p.width, p.height]);
                shaderProgram.setUniform('u_time', p.millis() / 1000.0);
                shaderProgram.setUniform('u_seed', currentSeed); // Pass the dynamic seed
                shaderProgram.setUniform('u_blobs', blobData);
                shaderProgram.setUniform('u_blob_count', blobData.length / 3);

                p.plane(p.width, p.height);
            };

            p.windowResized = () => {
                p.resizeCanvas(p.windowWidth, p.windowHeight);
            };
        };

        new p5(sketch);
    </script>
</body>
</html>
