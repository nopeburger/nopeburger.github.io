<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Flow Fractal by Nopeburger</title>
  <style>
    html, body { margin: 0; padding: 0; background: #000; overflow: hidden; }
    canvas { display: block; touch-action: none; }
  </style>
  <!-- p5.js library with crossorigin to enable better error reporting -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js" crossorigin="anonymous"></script>
</head>
<body>
<script>
/**
 * Converts an HSL color value to RGB.
 * Assumes h, s, and l are contained in the set [0, 1] and
 * returns r, g, and b in the set [0, 1].
 */
function hslToRgb(h, s, l) {
  let r, g, b;

  if (s === 0) {
    r = g = b = l; // achromatic
  } else {
    const hue2rgb = (p, q, t) => {
      if (t < 0) t += 1;
      if (t > 1) t -= 1;
      if (t < 1/6) return p + (q - p) * 6 * t;
      if (t < 1/2) return q;
      if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
      return p;
    };

    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    const p = 2 * l - q;
    r = hue2rgb(p, q, h + 1/3);
    g = hue2rgb(p, q, h);
    b = hue2rgb(p, q, h - 1/3);
  }

  return [r, g, b];
}

// VERTEX SHADER
// Standard GLSL 1.00 for maximum compatibility
const vertSource = `
  precision highp float;
  attribute vec3 aPosition;
  
  uniform mat4 uModelViewMatrix;
  uniform mat4 uProjectionMatrix;
  
  void main() {
    gl_Position = uProjectionMatrix * uModelViewMatrix * vec4(aPosition, 1.0);
  }
`;

// FRAGMENT SHADER
const fragSource = `
  precision highp float;

  uniform vec2 u_resolution;
  uniform vec2 u_seed;     
  uniform vec2 u_offset;   
  uniform float u_scale;   
  uniform float u_time;

  // Uniforms for color
  uniform vec3 u_colorA;
  uniform vec3 u_colorB;

  void main() {
    // Normalize coordinates based on canvas resolution
    vec2 uv = (gl_FragCoord.xy - 0.5 * u_resolution.xy) / min(u_resolution.x, u_resolution.y);
    
    // Apply zoom and pan first
    vec2 z = (uv * u_scale) + u_offset;

    // --- GEOMETRIC INVERSION ---
    // Invert the coordinate system to turn the shape inside out.
    // The "Outside" (Infinity) maps to the Center (0,0).
    // The "Inside" (Zero) maps to the Edge (Infinity).
    float r2 = dot(z, z);
    // Prevent division by zero with a small epsilon
    if (r2 > 0.00001) {
        z = z / r2;
    } else {
        z = vec2(0.0); // Handle singularity
    }
    
    vec2 c = u_seed;
    
    float escape = 0.0;
    float dotZ = 0.0;
    
    // Orbit Trap for "Sacred Geometry" lines
    // We track the minimum distance to the axes (x=0 or y=0)
    float trap = 100.0;
    
    const float MAX_ITER = 100.0;
    
    // Julia Iteration
    // Use int loop for WebGL 1 compatibility
    for(int i = 0; i < 100; i++){
      // --- BURNING SHIP VARIATION ---
      // Taking the absolute value of z components before squaring.
      z = abs(z);
      
      float x = (z.x * z.x - z.y * z.y) + c.x;
      float y = (2.0 * z.x * z.y) + c.y;
      z = vec2(x, y);
      
      dotZ = dot(z,z);
      
      // Update Trap: Distance to axes
      // This reveals the internal "skeleton" of the fractal
      trap = min(trap, min(abs(z.x), abs(z.y)));
      
      if(dotZ > 4.0) {
        escape = float(i);
        break;
      }
    }
    
    // --- CALCULATE GEOMETRY LINES (ORBIT TRAP) ---
    // Calculated for BOTH Interior and Exterior to ensure visual interest everywhere.
    // Invert distance: closer to axis = brighter
    float geomLine = 1.0 / (1.0 + trap * 15.0);
    geomLine = pow(geomLine, 2.5); // Sharpen
    
    // White geometry lines
    vec3 geomColor = vec3(1.0) * geomLine * 0.5;

    // --- COLOR MIXING ---
    // Colors shift based on spatial position and time
    // We compute a rough "smoothIter" approximation for the interior to keep colors moving
    float iterForColor = (dotZ > 4.0) ? escape : 50.0; 
    float colorMix = 0.5 + 0.5 * sin(iterForColor * 0.2 + length(z) * 0.4 + u_time * 0.5);
    vec3 baseColor = mix(u_colorA, u_colorB, colorMix);
    
    vec3 finalColor = vec3(0.0);
    
    if(dotZ > 4.0) {
      // --- EXTERIOR RENDERING ---
      // Due to inversion, this usually appears in the Center of the screen (the inverted Infinity)
      
      // Smooth iteration count
      float smoothIter = escape - log2(log2(dotZ)) + 4.0;
      
      // Dynamic frequency adds "breathing" texture variation
      // Higher density for more intricate details
      float freq = 6.0 + sin(u_time * 0.2) * 3.0; 
      float phase = u_time * 0.4;
      
      // Primary contour pattern (Sine wave)
      float val = sin(smoothIter * freq - phase);
      
      // 1. Core Line: 
      float core = smoothstep(0.5, 0.98, val); 
      
      // 2. Radiating Glow:
      float glowSignal = smoothstep(-0.2, 1.0, val);
      float glow = pow(glowSignal, 3.0) * 1.0; 
      
      float intensity = core + glow;

      vec3 bgColor = baseColor * 0.02;
      
      // The main structure
      vec3 geometryColor = bgColor + baseColor * intensity;
      
      // Add a white "hot" core to the very center of the lines for contrast
      float hotCore = smoothstep(0.95, 1.0, val);
      geometryColor += vec3(1.0) * hotCore * 0.6;
      
      // Add Sacred Geometry Lines
      geometryColor += geomColor;

      // --- EDGE SMOOTHING ---
      // Smooth out the sharp mask effect at the fractal boundary
      // We fade from the exterior geometry color to the INTERIOR look
      float edgeFade = 1.0 - smoothstep(MAX_ITER - 15.0, MAX_ITER, smoothIter);
      
      // The interior look is the base color + geometry lines
      vec3 interiorLook = (baseColor * 0.02) + geomColor;
      
      finalColor = mix(interiorLook, geometryColor, edgeFade);

    } else {
      // --- INTERIOR RENDERING ---
      // Due to inversion, this usually appears at the Edges of the screen (the inverted Zero)
      // Render the Orbit Trap lines.
      
      vec3 interiorBg = baseColor * 0.02; 
      finalColor = interiorBg + geomColor;
    }
    
    gl_FragColor = vec4(finalColor, 1.0);
  }
`;

// --- STATE VARIABLES ---
let fractalShader;

// Mutable initial base to support random start
let initialBase = { x: -0.8, y: 0.156 };

// Seed (Shape)
let currentBase = { x: -0.8, y: 0.156 };
let targetBase = { x: -0.8, y: 0.156 };

// Camera (Scale & Offset)
// Start centered (0,0) with enough zoom out (Scale 2.0) to see the shape
let currentScale = 2.0; 
let currentOffset = { x: 0.0, y: 0.0 };

// Target variables
let targetScale = 2.0;
let targetOffset = { x: 0.0, y: 0.0 };

// Color State
let hue = 0; // 0 to 1 cycle

// Interaction Time Tracking
let lastInteractionTime = 0;
const IDLE_DELAY = 3000; // 3 seconds

function setup() {
  // Create canvas that fills the window
  createCanvas(windowWidth, windowHeight, WEBGL);
  noStroke();
  
  // Try to create the shader, if it fails, p5 might log to console
  try {
    fractalShader = createShader(vertSource, fragSource);
  } catch(e) {
    console.error("Shader creation failed:", e);
  }

  // Randomize initial base shape so every session is unique
  let dx = random(-0.6, 0.6);
  let dy = random(-0.6, 0.6);
  
  // Constrain to known interesting regions of Burning Ship
  initialBase.x = constrain(initialBase.x + dx, -1.75, -0.4);
  initialBase.y = constrain(initialBase.y + dy, -0.8, 0.8);
  
  // Set initial state to the new randomized base
  currentBase = { ...initialBase };
  targetBase = { ...initialBase };
  
  // FORCE Start Centered
  currentScale = 2.0;
  currentOffset = { x: 0.0, y: 0.0 };
  targetOffset = { x: 0.0, y: 0.0 };
  
  lastInteractionTime = millis();
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
}

function mousePressed() {
  randomizeTarget();
  lastInteractionTime = millis();
  return false; 
}

function touchStarted() {
  randomizeTarget();
  lastInteractionTime = millis();
  return false;
}

function randomizeTarget() {
  // 1. Randomize Seed (Shape) - DRASTIC EVOLUTION (Keep as requested)
  // Larger range (+/- 0.6) causes the shape to morph significantly
  let dx = random(-0.6, 0.6);
  let dy = random(-0.6, 0.6);
  
  // Allow a wider range of Burning Ship shapes
  // Slightly tightened max X to avoid the purely chaotic dispersion region
  targetBase.x = constrain(targetBase.x + dx, -1.8, -0.2);
  targetBase.y = constrain(targetBase.y + dy, -0.8, 0.8);
  
  // 2. Camera Position - MOVE TO CLICK LOCATION
  // We want the point clicked by the user to become the new center of the screen.
  
  // Replicate physics state (Drift + Zoom) to get accurate click coordinate
  let t = millis() / 1000.0;
  
  // Replicate Breathing Zoom
  let zoomPhase = sin(t * 0.2); 
  let zoomFactor = map(zoomPhase, -1, 1, 0.8, 1.5); 
  let effectiveScale = currentScale * zoomFactor;

  // Replicate Camera Drift
  let driftX = map(noise(t * 0.1 + 200.0), 0, 1, -0.6, 0.6);
  let driftY = map(noise(t * 0.1 + 300.0), 0, 1, -0.6, 0.6);
  let effectiveOffsetX = currentOffset.x + driftX;
  let effectiveOffsetY = currentOffset.y + driftY;

  // Calculate Normalized Device Coordinates (-0.5 to 0.5 roughly) based on min dimension
  let minDim = min(width, height);
  let ndcX = (mouseX - width / 2) / minDim;
  
  // Note: Screen Y goes down (positive), but in Fractal/Complex plane Y goes up (positive).
  // So we invert the Y relative to the center.
  let ndcY = -(mouseY - height / 2) / minDim;
  
  // Convert to World (Fractal) Coordinate
  let clickX = (ndcX * effectiveScale) + effectiveOffsetX;
  let clickY = (ndcY * effectiveScale) + effectiveOffsetY;
  
  // Set target to this new point.
  // We subtract the drift component because the draw loop will re-add it.
  // This ensures the "base" target centers on the click.
  targetOffset.x = clickX - driftX;
  targetOffset.y = clickY - driftY;
}

function draw() {
  // Check if shader is ready
  if (!fractalShader) return;

  // Clear background
  background(0);
  
  let t = millis() / 1000.0;
  
  // --- IDLE RESET LOGIC ---
  // If no interaction for a set time, gently drift the shape target back to initial
  if (millis() - lastInteractionTime > IDLE_DELAY) {
    targetBase.x = lerp(targetBase.x, initialBase.x, 0.02);
    targetBase.y = lerp(targetBase.y, initialBase.y, 0.02);
  }
  
  // --- PHYSICS / INTERPOLATION ---
  let lerpFactor = 0.05;
  
  // Interpolate Seed (The "Center" of the shape)
  currentBase.x = lerp(currentBase.x, targetBase.x, lerpFactor);
  currentBase.y = lerp(currentBase.y, targetBase.y, lerpFactor);
  
  // Interpolate Offset (Target Camera Move)
  currentOffset.x = lerp(currentOffset.x, targetOffset.x, lerpFactor);
  currentOffset.y = lerp(currentOffset.y, targetOffset.y, lerpFactor);
  
  // --- IDLE EVOLUTION & ANIMATION ---
  
  // 1. Shape Evolution (Fractals Inside)
  // Use Perlin noise to create a continuous, wandering path for the seed around its base.
  // Increased speed (0.25) and amplitude (+/- 0.4) for drastic morphing.
  let seedNoiseX = map(noise(t * 0.25), 0, 1, -0.4, 0.4);
  let seedNoiseY = map(noise(t * 0.25 + 100.0), 0, 1, -0.4, 0.4);
  
  let finalSeedX = currentBase.x + seedNoiseX;
  let finalSeedY = currentBase.y + seedNoiseY;

  // 2. Camera Drift (Exploration)
  // Wider range for more exploration (+/- 0.6) and faster drift (0.1)
  let driftX = map(noise(t * 0.1 + 200.0), 0, 1, -0.6, 0.6);
  let driftY = map(noise(t * 0.1 + 300.0), 0, 1, -0.6, 0.6);
  
  let finalOffsetX = currentOffset.x + driftX;
  let finalOffsetY = currentOffset.y + driftY;

  // 3. Breathing Zoom (Revealing Depth)
  // Gently oscillate the zoom level
  // Range: 0.8x (Zoom In) to 1.5x (Zoom Out)
  let zoomPhase = sin(t * 0.2); 
  let zoomFactor = map(zoomPhase, -1, 1, 0.8, 1.5); 
  let finalScale = currentScale * zoomFactor;

  // --- COLOR LOGIC ---
  // Slowly rotate hue over time
  hue = (hue + 0.0005) % 1.0; // Slow cycle
  
  // Generate complementary pair
  const rgbA = hslToRgb(hue, 0.6, 0.5); 
  const rgbB = hslToRgb((hue + 0.5) % 1.0, 0.6, 0.5);
  
  // --- SHADER UNIFORMS ---
  shader(fractalShader);
  
  fractalShader.setUniform('u_resolution', [width, height]);
  fractalShader.setUniform('u_seed', [finalSeedX, finalSeedY]);
  fractalShader.setUniform('u_scale', finalScale);
  fractalShader.setUniform('u_offset', [finalOffsetX, finalOffsetY]);
  fractalShader.setUniform('u_time', t);
  
  // Pass calculated colors
  fractalShader.setUniform('u_colorA', rgbA);
  fractalShader.setUniform('u_colorB', rgbB);
  
  // Draw full screen rect
  rect(-width/2, -height/2, width, height);
}
</script>
</body>
</html>