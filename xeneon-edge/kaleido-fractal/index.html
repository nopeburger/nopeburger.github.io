<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
    <title>Fractal Mandala</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
      body, html { margin: 0; padding: 0; background: #000; overflow: hidden; }
      #canvas-container { width: 100vw; height: 100vh; }
    </style>
    <script type="importmap">
    {
      "imports": {
        "p5": "https://esm.sh/p5@1.9.0"
      }
    }
    </script>
  </head>
  <body>
    <div id="root"></div>
    <div id="canvas-container"></div>
    
    <script type="module">
      import p5 from 'p5';

      // --- Shader Definitions ---
      const vert = `
        attribute vec3 aPosition;
        attribute vec2 aTexCoord;

        varying vec2 vTexCoord;

        void main() {
          vTexCoord = aTexCoord;
          vec4 positionVec4 = vec4(aPosition, 1.0);
          positionVec4.xy = positionVec4.xy * 2.0 - 1.0;
          gl_Position = positionVec4;
        }
      `;

      const frag = `
        precision highp float;

        varying vec2 vTexCoord;

        uniform vec2 u_resolution;
        uniform float u_time;
        uniform float u_symmetry;
        uniform float u_complexity;
        uniform float u_zoom;
        uniform float u_rotation;
        uniform float u_fold;
        uniform float u_contrast;

        #define PI 3.14159265359

        // Rotate a vector
        vec2 rotate(vec2 v, float a) {
            float s = sin(a);
            float c = cos(a);
            return mat2(c, -s, s, c) * v;
        }

        void main() {
            // Normalize coordinates
            vec2 uv = (gl_FragCoord.xy * 2.0 - u_resolution.xy) / u_resolution.y;
            vec2 uv0 = uv;
            
            // Initial Zoom
            uv *= u_zoom;

            vec3 finalColor = vec3(0.0);
            
            // Iterate to create fractal layers
            float iterations = floor(u_complexity);
            
            for (float i = 0.0; i < 20.0; i++) {
                if (i >= iterations) break;
                
                // Space Folding (Symmetry)
                uv = abs(uv);
                uv -= 0.5 * u_fold; 
                uv = rotate(uv, u_time * 0.05 + u_rotation);
                
                // Fractal Scaling
                uv *= 1.1 + sin(u_time * 0.1) * 0.05;

                // Accumulate distance/density
                float d = length(uv) * exp(-length(uv0));
                
                // Create the "glow" lines
                d = sin(d * 8.0 + u_time)/8.0;
                d = abs(d);
                
                // Invert for white-on-black lines (organic look)
                d = pow(0.01 / d, 1.2);

                finalColor += vec3(d);
            }
            
            // Organic noise texture overlay simulation
            float noise = fract(sin(dot(uv0.xy, vec2(12.9898, 78.233))) * 43758.5453);
            finalColor += noise * 0.05;

            // Contrast adjustments
            finalColor = pow(finalColor, vec3(u_contrast));
            
            // Force Grayscale
            float gray = dot(finalColor, vec3(0.299, 0.587, 0.114));
            
            // Vignette
            float vignette = 1.0 - smoothstep(0.5, 1.5, length(uv0));
            gray *= vignette;

            gl_FragColor = vec4(vec3(gray), 1.0);
        }
      `;

      // --- Application State ---
      let params = {
        symmetry: 6,
        complexity: 8,
        speed: 0.5,
        zoom: 1.5,
        contrast: 1.2,
        rotation: 0.5,
        fold: 1.0,
      };

      let time = 0;

      // Randomization Logic with Constraints
      const randomizeParams = () => {
        params = {
          symmetry: Math.floor(Math.random() * 10) + 3,
          complexity: Math.floor(Math.random() * 9) + 2, // Max 10 (2+8)
          speed: Math.random() * (1.3 - 0.4) + 0.4,       // Min 0.4, Max 1.3
          zoom: Math.random() * (3 - 1) + 1,              // Min 1, Max 3
          contrast: Math.random() * (1.75 - 0.8) + 0.8,   // Max 1.75
          rotation: Math.random() * 6.28,
          fold: Math.random() * (2.5 - 0.5) + 0.5,
        };
        console.log("Randomized Params:", params);
      };

      // --- P5 Sketch ---
      const sketch = (p) => {
        let theShader;

        p.setup = () => {
          const c = p.createCanvas(p.windowWidth, p.windowHeight, p.WEBGL);
          c.parent('canvas-container');
          p.noStroke();
          theShader = p.createShader(vert, frag);
          p.pixelDensity(1);
          
          // Initial Randomize on load? No, use defaults first as per original design, 
          // or we can randomize. Keeping defaults ensures a stable start.
        };

        p.draw = () => {
          if (!theShader) return;

          // Update Time
          time += 0.05 * params.speed;

          p.shader(theShader);
          theShader.setUniform('u_resolution', [p.width, p.height]);
          theShader.setUniform('u_time', time);
          theShader.setUniform('u_symmetry', params.symmetry);
          theShader.setUniform('u_complexity', params.complexity);
          theShader.setUniform('u_zoom', params.zoom);
          theShader.setUniform('u_rotation', params.rotation);
          theShader.setUniform('u_fold', params.fold);
          theShader.setUniform('u_contrast', params.contrast);

          p.rect(0, 0, p.width, p.height);
        };

        p.windowResized = () => {
          p.resizeCanvas(p.windowWidth, p.windowHeight);
        };

        p.mousePressed = () => {
          randomizeParams();
        };
      };

      // Initialize P5
      new p5(sketch);
    </script>
  </body>
</html>